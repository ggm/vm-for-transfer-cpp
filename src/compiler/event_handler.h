/*Copyright (C) 2011  Gabriel Gregori Manzano

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#ifndef EVENT_HANDLER_H_
#define EVENT_HANDLER_H_

#include <map>
#include <vector>

#include <event.h>
#include <code_generator.h>
#include <symbol_table.h>

enum TRANSFER_STAGE {
  TRANSFER, INTERCHUNK, POSTCHUNK
};

enum TRANSFER_DEFAULT {
  CHUNK, LU
};

/**
 * Contains all the handlers of the XML events generated by the parser. This
 * class helps abstracting some of the things a code generator doesn't need to
 * know, like in which transfer stage we are.
 */
class EventHandler {

public:

  EventHandler();
  EventHandler(const EventHandler&);
  ~EventHandler();
  EventHandler& operator=(const EventHandler&);
  void copy(const EventHandler&);

  void setCodeGenerator(CodeGenerator *);

  void throwError(const Event &, const wstring &) const;
  void checkAttributeExists(const Event &, wstring) const;
  void checkMacro(const Event &) const;
  bool isContainer(const Event &) const;
  vector<wstring> getPartAttribute(const Event &);
  wstring unEscape(wstring &) const;

  void handleEndOfParsing();

  // Handlers for each of the xml elements.
  void handleTransferStart(const Event &);
  void handleTransferEnd(const Event &);
  void handleInterchunkStart(const Event &);
  void handleInterchunkEnd(const Event &);
  void handlePostchunkStart(const Event &);
  void handlePostchunkEnd(const Event &);
  void handleDefCatStart(const Event &);
  void handleDefCatEnd(const Event &);
  void handleCatItemStart(const Event &);
  void handleDefAttrStart(const Event &);
  void handleDefAttrEnd(const Event &);
  void handleAttrItemStart(const Event &);
  void handleDefVarStart(const Event &);
  void handleDefListStart(const Event &);
  void handleDefListEnd(const Event &);
  void handleDefListItemStart(const Event &);
  void handleSectionDefMacrosStart(const Event &);
  void handleDefMacroStart(const Event &);
  void handleDefMacroEnd(const Event &);
  void handleSectionRulesStart(const Event &);
  void handleSectionRulesEnd(const Event &);
  void handleRuleStart(const Event &);
  void handlePatternStart(const Event &);
  void handlePatternEnd(const Event &);
  void handlePatternItemStart(const Event &);
  void handleActionStart(const Event &);
  void handleActionEnd(const Event &);
  void handleCallMacroStart(const Event &);
  void handleCallMacroEnd(const Event &);
  void handleWithParamStart(const Event &);
  void handleChooseStart(const Event &);
  void handleChooseEnd(const Event &);
  void handleWhenStart(const Event &);
  void handleWhenEnd(const Event &);
  void handleOtherwiseStart(const Event &);
  void handleTestEnd(const Event &);
  void handleBStart(const Event &);
  void handleLitStart(const Event &);
  void handleLitTagStart(const Event &);
  void handleTagsEnd(const Event &);
  void handleLuEnd(const Event &);
  void handleMluEnd(const Event &);
  void handleLuCountStart(const Event &);
  void handleChunkStart(const Event &);
  void handleChunkEnd(const Event &);
  void handleEqualEnd(const Event &);
  void handleAndEnd(const Event &);
  void handleOrEnd(const Event &);
  void handleNotEnd(const Event &);
  void handleOutEnd(const Event &);
  void handleVarStart(const Event &);
  void handleInEnd(const Event &);
  void handleClipStart(const Event &);
  void handleListStart(const Event &);
  void handleLetEnd(const Event &);
  void handleConcatEnd(const Event &);
  void handleAppendStart(const Event &);
  void handleAppendEnd(const Event &);
  void handleGetCaseFromStart(const Event &);
  void handleGetCaseFromEnd(const Event &);
  void handleCaseOfStart(const Event &);
  void handleModifyCaseEnd(const Event &);
  void handleBeginsWithEnd(const Event &);
  void handleBeginsWithListEnd(const Event &);
  void handleEndsWithEnd(const Event &);
  void handleEndsWithListEnd(const Event &);
  void handleContainsSubstringEnd(const Event &);

private:
  /// Store the current transfer stage.
  TRANSFER_STAGE transferStage;

  /// Store the default unit in the transfer.
  TRANSFER_DEFAULT transferDefault;

  /// The code generator to use when handling the events.
  CodeGenerator *codeGenerator;

  /// The symbol table is used to check information about symbols.
  SymbolTable symbolTable;

  /// Store copies of the macros which aren't already defined, to check later.
  vector<Event> uncheckedMacros;

  /// Store category definitions and a reference to the current one.
  map<wstring, vector<wstring> > defCats;
  vector<wstring> *currentDefCat;

  /// Store attributes definitions and a reference to the current one.
  map<wstring, vector<wstring> > defAttrs;
  vector<wstring> *currentDefAttr;

  /// Store variables definitions and their default values.
  map<wstring, wstring> defVars;

  /// Store list definitions and a reference to the current one.
  map<wstring, vector<wstring> > defLists;
  vector<wstring> *currentDefList;
};

#endif /* EVENT_HANDLER_H_ */
