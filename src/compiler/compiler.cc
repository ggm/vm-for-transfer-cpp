/*Copyright (C) 2011  Gabriel Gregori Manzano

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <compiler.h>

#include <wstring_utils.h>
#include <assembly_code_generator.h>

Compiler::Compiler() {
  inputFileName = NULL;
  outputFileName = NULL;

  //For now, there is only one code generator.
  codeGenerator = new AssemblyCodeGenerator();
}

Compiler::Compiler(const Compiler &c) {
  copy(c);
}

Compiler::~Compiler() {
  inputFileName = NULL;
  outputFileName = NULL;
  delete codeGenerator;
  codeGenerator = NULL;
}

Compiler& Compiler::operator=(const Compiler &c) {
  if (this != &c) {
    this->~Compiler();
    this->copy(c);
  }
  return *this;
}

void Compiler::copy(const Compiler &c) {
  inputFileName = c.inputFileName;
  outputFileName = c.outputFileName;
}

/**
 * Set the debug capabilities using the file passed.
 *
 * @param fileName the name of the file where the messages will be stored
 */
void Compiler::setDebug(char *fileName) {
  debugFile.open(fileName);
}

/**
 * Set the input file to read the transfer rules.
 *
 * @param fileName input file's name
 */
void Compiler::setInputFile(char *fileName) {
  inputFileName = fileName;
}

/**
 * Set the output file to save the compiler's output.
 *
 * @param fileName output file's name
 */
void Compiler::setOutputFile(char *fileName) {
  outputFileName = fileName;
}

/**
 * Compile the contents of the transfer file to the chosen intermediate
 * representation.
 */
void Compiler::compile() {
  createParser();

  try {
    parser.parse();
    writeOutput(codeGenerator->getWritableCode());
  } catch (CompilerException &c) {
    debugMessage(c.getMessage());
    wcerr << L"Error: " << c.getMessage() << endl;
  } catch (exception &e) {
    debugMessage(WstringUtils::stows(e.what()));
    cerr << e.what() << endl;
  }
}

/*
 * If debugging is active, print a debug message on the file specified.
 *
 * @param msg the message to print.
 */
void Compiler::debugMessage(const wstring &msg) {
  if (debugFile.is_open()) {
    debugFile << msg << endl;
  }
}

/*
 * Write the output of the compiling process to the file specified.
 *
 * @code the code generated by the generator.
 */
void Compiler::writeOutput(const wstring &code) const {
  if (outputFileName != NULL) {
    wofstream file(outputFileName);
    file << code;
  } else {
    wcout << code;
  }
}

/**
 * Create the parser depending on the options set. If there is a input file name
 * use that, in other case, read from stdin directly.
 */
void Compiler::createParser() {
  if (inputFileName != NULL) {
    parser = XmlParser(inputFileName);
  } else {
    parser = XmlParser(STDIN_FILENO);
  }
  parser.setCodeGenerator(codeGenerator);
}
